---
Title: Mitigating The Cost Of Abstractions pt6. Using Virtual Functions.
---

### Mitigating The Cost Of Abstractions pt6. Using Virtual Functions.

This post is going to be a mix of discussing architecture, as well as performance.

#### A description of virtual functions

Both virtual function calls, and calls to interface methods, are less straightforward than a normal method call.

With a normal method call, the compiler knows what function is going to be called, and so the Jitter is able to simply jump to the correct function when the code runs.

With virtual functions and interface methods, the compiler can't know which method is going to be called, since it depends on the type passed in.

As such it builds a VTable, which the runtime checks to see which method it should call, and jumps to that.

There are 3 relevant performance costs here.

1. The VTable check takes time. This of course slows down performance.

2. The Jitter cannot inline a virtual function, since it doesn't know which function will finally be called. This limits it's ability to optimise function calls, especially when a fast function is called in a tight loop.

3. A VTable must be created for every virtual function. This increases the total amount of stuff the runtime has to hold in memory to run the code. This uses RAM, and also makes a cache miss more likely.

For plenty of code bases this will be irrelevant. If one uses virtual functions judiciously, and only on methods that are anyways long and slow, there is unlikely to be a noticeable performance hit.

On the other hand, just one virtual function call in the wrong place can wreck performance under certain circumstances. See my post about using functions to do arithmetic for an example of an interface method which caused a serious performance hit, and the trick I used to avoid it.

Note that if you call a method on an implementation of interface directly, or you call a sealed override of a virtual method directly, there is no performance hit. It's only when the compiler cannot be sure what method will be called - ie when you call the method on the interface, not the implementation, or call a non-sealed virtual function - that you get a performance hit.

So the first tips I can give you are:

**Don't use virtual functions unless there is a specific reason too!** 

**Always seal your virtual function overrides, unless there is a specific reason not to!**

#### Architectural Advantages Of Interfaces

As I said above, virtual functions and interfaces have similiar costs, although interfacea _may_ be slightly slower, depending on use case. However interfaces tend to have a positive effect on architecture, whereas virtual functions raise a number of problems.

Firstly let's look at interfaces.

When you program to an interface, it tends to improve the quality of your code, as it more strictly divides the inside and the outside of the class. As such it encourages a loosely coupled architecture. Furthermore it makes testing easier, and makes it simple to plug in a different class or remove an old one.

Especially if one uses standard naming conventions, an interface is easy to spot, and is explicit about not providing an implementation. As such when one is using an interface one is fully aware that one is dealing with a contract, not an implementation.

A class can inherit multiple interface, and can implement them both explicitly and implicitly. Thus accepting an interface in your API as opposed to a class gives far more flexibility to the client code as to how to make use of the API.

An interface implementation is also non-virtual by default. As such you only pay the cost of using a Virtual function if you access the implementation via the interface rather than directly calling the method on the implementing class, which means interfaces are pay as you go. If you don't use them, they don't cost you. They will still increase the amount of memory needed in RAM, but if they're never used, they won't clog up the cache.

As such I believe that even on the most performance critical code it's worth programming to an interface. The wonderful thing about interfaces is they're a doddle to remove if they are only implemented once, and so once the code is done, one can remove any unneeded interfaces on internal code, and get an instant performance boost.

#### Architectural Issues With Virtual Functions

Now virtual functions do have some advantages in specific cases. However they also come with significant costs.

Let's consider Java for example. In Java all methods are virtual by default, unless explicitly sealed. As a result not only is there a huge performance cost, but there is a huge safety cost.

A class can never be sure when calling one of it's own methods what it's effect will be. Maybe the method will be overridden, and bugs will appear.

Similarly, one can never safely override a method, because one doesn't know how the method is used internally. The fact that it's virtual is no proof it's safe to override it, since all methods are virtual by default.

Fortunately in C# virtual methods are less pervasive, as methods are sealed by default.

However as a technique to modify behaviour they are less elegant than interfaces.

Firstly they don't divide implementation and definition neatly, but instead cause tight coupling as inheriting classes and base classes both are directly effected by the others implementation.

Secondly accepting a class, even an abstract one, in an API gives far less flexibility to the client code, as all objects passed in to that API must inherit from that class, and as such cannot inherit from anything else.

Thirdly virtual function overrides are virtual by default. As such, even if you access the inheriting class directly, you still pay for a virtual function call. They are not pay as you go, unless explicitly sealed, moving away from the 'pit of success' interfaces try to provide.

Fourthly the implementation of the parent class may depend on the virtual function that is being overridden. It is easy to unwittingly write code that is dependent on the base method implementation. Thus one can unknowingly break code by overriding a function. Meanwhile when relying on interface methods it is explicit that the interface has no given implementation, and so developers are aware not to rely on a specific implementation of the interface.

Fifth interfaces are more explicit than virtual methods. When implementing an interface it is clear what has to be done: you provide a method for every member of the interface. When inheriting from a parent class it is not clear which virtual functions should be overridden, and what effect they will have on the parent class. Similarly when recieving an interface, it is obvious that the exact implementation will change, so one does not rely on it. However when receiving a class, it is not at all obvious at first sight if the class has virtual functions, and what their effect is.

Given my preferences for interfaces over virtual functions, let's go through common use cases for virtual functions, and whether or not we can replace them with interfaces.

#### Use Case 1: Abstract Classes

Unfortunately interfaces in C# have limitations. As such if one wants to provide operator overloads or implicit casts to interfaced, one has no choice but to use an abstract class instead, and replace interface methods with abstract methods.

With C# 8 we should hopefully see this issue corrected, and we can start converting abstract classes to interfaces.

Another limitation with interfaces is that one cannot provide an implementation in interfaces for behaviour that is resultant of the interface methods.

So for example

``` csharp

public interface MathsDefiner
{
    int Add(int a, int b);
    int Negative(int a);
}

```

Now I want to define that subtraction is the same as adding the negative of the number, so there should be a method ` int Subtract(int a, int b) => Add(a, Negative(b))`.

However I can't put Subtract in the interface because then someone may implement it incorrectly, and because I don't want to pay for an extra virtual function call.

Currently one can use extension methods like so

``` csharp

public interface IMathsDefiner
{
    int Add(int a, int b);
    int Negative(int a);
}

public static class IMathsDefinerExtensions
{
    public static int Subtract(this IMathsDefiner mathsDef, int a, int b) => Add(a, Negative(b));
}

```

However it would be understandable if someone wanted all the methods to be in the same place, or didn't want the extra noise of extension methods, and so chose to use an abstract class instead.

C# 8 should again hopefully mitigate that issue.

Abstract classes are annoying as they do not support multiple inheritance. However they are often necessary, and so long as they are just used as an interface+ they're not terribly problematic. Just remember to seal any abstract methods that your implement.

#### Use Case 2. Allowing repl

